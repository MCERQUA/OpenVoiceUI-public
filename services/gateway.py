"""
GatewayConnection — Clawdbot Gateway WebSocket client.

Maintains a single persistent WebSocket connection with auto-reconnect
and exponential backoff. Handshake is performed once per connection
(not per message). A dedicated background daemon thread owns the asyncio
event loop and WS so the object is safe to call from any Flask thread.

Extracted from server.py (P2-T2).
Upgraded to persistent connection in PG-T2 (Recipe R3).

Usage:
    from services.gateway import gateway_connection

    # Synchronous call from any thread (Flask request, background thread, etc.):
    gateway_connection.stream_to_queue(
        event_queue, message, session_key, captured_actions
    )
"""

import asyncio
import base64
import hashlib
import json
import logging
import os
import threading
import time
import uuid
from pathlib import Path

import websockets
from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey
from cryptography.hazmat.primitives.serialization import (
    Encoding, NoEncryption, PrivateFormat, PublicFormat, load_pem_private_key
)

logger = logging.getLogger(__name__)

# Path to the externalized system prompt file
_PROMPT_FILE = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'prompts', 'voice-system-prompt.md')
_PROMPT_FALLBACK = (
    "You are a helpful voice assistant. Respond in a natural, conversational tone. "
    "Avoid markdown formatting (no #, -, *, tables, etc.). "
    "Avoid bullet points and numbered lists — use paragraphs instead. "
    "Be brief and direct. In WEBCHAT mode, never use the TTS tool. Always reply as plain text."
)


def _load_generated_tracks() -> str:
    """Return a formatted list of Jambot Originals for injection into the system prompt."""
    try:
        metadata_file = Path(__file__).parent.parent / 'generated_music' / 'generated_metadata.json'
        if not metadata_file.exists():
            return ''
        with open(metadata_file) as f:
            metadata = json.load(f)
        titles = sorted({v.get('title', k) for k, v in metadata.items() if v.get('title')})
        if not titles:
            return ''
        track_list = ', '.join(f'"{t}"' for t in titles)
        return (
            f"\n\nJambot Originals playlist (generated_music folder) — {len(titles)} tracks: {track_list}. "
            "To play a specific song use [MUSIC_PLAY:exact title]. "
            "The playlist is set to 'generated' so [MUSIC_PLAY] without a title plays a random Jambot Original. "
            "New songs generated by Suno automatically appear in this list."
        )
    except Exception:
        return ''


def _load_system_prompt() -> str:
    """Load system prompt from prompts/voice-system-prompt.md, stripping comment lines."""
    try:
        with open(_PROMPT_FILE, 'r') as f:
            lines = f.readlines()
        content = ''.join(l for l in lines if not l.startswith('#')).strip()
        base = content if content else _PROMPT_FALLBACK
    except Exception:
        base = _PROMPT_FALLBACK
    return base + _load_generated_tracks()


def _load_device_identity() -> dict:
    """Load or generate the Ed25519 device identity for OpenClaw auth."""
    identity_file = os.path.join(os.path.dirname(__file__), '..', '.device-identity.json')
    if os.path.exists(identity_file):
        with open(identity_file) as f:
            return json.load(f)
    # Generate new Ed25519 key pair
    private_key = Ed25519PrivateKey.generate()
    public_key = private_key.public_key()
    raw_pub = public_key.public_bytes(Encoding.Raw, PublicFormat.Raw)
    device_id = hashlib.sha256(raw_pub).hexdigest()
    pub_pem = public_key.public_bytes(Encoding.PEM, PublicFormat.SubjectPublicKeyInfo).decode()
    priv_pem = private_key.private_bytes(
        Encoding.PEM, PrivateFormat.PKCS8, NoEncryption()
    ).decode()
    identity = {"deviceId": device_id, "publicKeyPem": pub_pem, "privateKeyPem": priv_pem}
    with open(identity_file, 'w') as f:
        json.dump(identity, f)
    logger.info(f"Generated new device identity: {device_id[:16]}...")
    return identity


def _sign_device_connect(identity: dict, client_id: str, client_mode: str,
                          role: str, scopes: list, token: str, nonce: str) -> dict:
    """Sign the device connect payload with Ed25519 for OpenClaw ≥ 2026.2.24."""
    signed_at = int(time.time() * 1000)
    scopes_str = ",".join(scopes)
    payload = "|".join([
        "v2", identity["deviceId"], client_id, client_mode,
        role, scopes_str, str(signed_at), token or "", nonce
    ])
    private_key = load_pem_private_key(identity["privateKeyPem"].encode(), password=None)
    signature = private_key.sign(payload.encode())
    sig_b64 = base64.b64encode(signature).decode()
    raw_pub = private_key.public_key().public_bytes(Encoding.Raw, PublicFormat.Raw)
    pub_b64url = base64.urlsafe_b64encode(raw_pub).rstrip(b'=').decode()
    return {
        "id": identity["deviceId"],
        "publicKey": pub_b64url,
        "signature": sig_b64,
        "signedAt": signed_at,
        "nonce": nonce
    }


class GatewayConnection:
    """
    Persistent WebSocket connection to the Clawdbot (OpenClaw) Gateway.

    A single WS connection is maintained across all messages.  On disconnect
    the connection is re-established with exponential backoff before the next
    message is sent.  Handshake (challenge/hello) is performed once per
    connection — not once per message.

    A background daemon thread runs the asyncio event loop that owns the WS.
    stream_to_queue() is synchronous — call it from any Flask thread.
    """

    DEFAULT_URL = 'ws://127.0.0.1:18791'
    # Exponential backoff delays in seconds between reconnect attempts
    BACKOFF_DELAYS = [1, 2, 4, 8, 16, 30, 60]

    def __init__(self):
        self._ws = None
        self._connected = False
        self._loop: asyncio.AbstractEventLoop = None
        self._loop_thread: threading.Thread = None
        self._ws_lock: asyncio.Lock = None          # created in loop thread
        self._stream_lock: asyncio.Lock = None      # serialises concurrent recv calls
        self._started = False
        self._start_lock = threading.Lock()
        self._backoff_idx = 0
        self._last_disconnect_time = 0.0

    # ------------------------------------------------------------------ #
    # Properties                                                           #
    # ------------------------------------------------------------------ #

    @property
    def url(self):
        # _custom_url set by GatewayRouter for non-default gateways
        return getattr(self, '_custom_url', None) or os.getenv('CLAWDBOT_GATEWAY_URL', self.DEFAULT_URL)

    @property
    def auth_token(self):
        return os.getenv('CLAWDBOT_AUTH_TOKEN')

    def is_configured(self):
        """Return True if CLAWDBOT_AUTH_TOKEN is set."""
        return bool(self.auth_token)

    # ------------------------------------------------------------------ #
    # Background loop management                                           #
    # ------------------------------------------------------------------ #

    def _ensure_started(self):
        """Start the background event loop daemon thread if not running."""
        if self._started:
            return
        with self._start_lock:
            if self._started:
                return

            ready = threading.Event()

            def _loop_main():
                self._loop = asyncio.new_event_loop()
                asyncio.set_event_loop(self._loop)
                self._ws_lock = asyncio.Lock()
                self._stream_lock = asyncio.Lock()
                ready.set()
                self._loop.run_forever()

            self._loop_thread = threading.Thread(
                target=_loop_main,
                name='gateway-ws-loop',
                daemon=True
            )
            self._loop_thread.start()
            ready.wait(timeout=5.0)
            self._started = True
            logger.info("### Gateway persistent WS background loop started")

    # ------------------------------------------------------------------ #
    # Handshake                                                            #
    # ------------------------------------------------------------------ #

    async def _handshake(self, ws):
        """
        Perform the 3-step Gateway handshake:
          1. Receive connect.challenge
          2. Send connect request with auth token
          3. Receive hello (success) or raise RuntimeError on failure
        """
        challenge_response = await ws.recv()
        challenge_data = json.loads(challenge_response)
        if (challenge_data.get('type') != 'event'
                or challenge_data.get('event') != 'connect.challenge'):
            raise RuntimeError(
                f"Expected connect.challenge, got: {challenge_data}"
            )

        # Extract nonce from challenge for device signing
        nonce = challenge_data.get('payload', {}).get('nonce', '')
        scopes = ["operator.read", "operator.write"]
        identity = _load_device_identity()
        device_block = _sign_device_connect(
            identity, "cli", "cli", "operator", scopes, self.auth_token, nonce
        )

        # Connect format — client.id must be "cli" (gateway validates this as a constant)
        handshake = {
            "type": "req",
            "id": f"connect-{uuid.uuid4()}",
            "method": "connect",
            "params": {
                "minProtocol": 3, "maxProtocol": 3,
                "client": {"id": "cli", "version": "1.0.0", "platform": "linux", "mode": "cli"},
                "role": "operator",
                "scopes": scopes,
                "caps": ["tool-events"], "commands": [], "permissions": {},
                "auth": {"token": self.auth_token},
                "device": device_block,
                "locale": "en-US",
                "userAgent": "openvoice-ui-voice/1.0.0"
            }
        }
        await ws.send(json.dumps(handshake))

        hello_response = await ws.recv()
        hello_data = json.loads(hello_response)
        if hello_data.get('type') != 'res' or hello_data.get('error'):
            raise RuntimeError(f"Gateway auth failed: {hello_data.get('error')}")

        return hello_data

    # ------------------------------------------------------------------ #
    # Connection management (async, runs in background loop)              #
    # ------------------------------------------------------------------ #

    async def _connect(self):
        """Open a new WS connection and perform handshake."""
        t_start = time.time()
        ws = await websockets.connect(self.url)
        try:
            await self._handshake(ws)
        except Exception:
            await ws.close()
            raise
        t_ms = int((time.time() - t_start) * 1000)
        self._ws = ws
        self._connected = True
        self._backoff_idx = 0
        logger.info(f"### Persistent WS connected + handshake done in {t_ms}ms")

    async def _disconnect(self):
        """Close WS and update state."""
        self._connected = False
        self._last_disconnect_time = time.time()
        if self._ws is not None:
            try:
                await self._ws.close()
            except Exception:
                pass
            self._ws = None

    async def _ensure_connected(self):
        """Ensure WS is alive; reconnect with backoff if not."""
        async with self._ws_lock:
            if self._connected and self._ws is not None:
                # Quick ping to verify the connection is still alive
                try:
                    pong_waiter = await self._ws.ping()
                    await asyncio.wait_for(pong_waiter, timeout=5.0)
                    return  # Connection healthy
                except Exception:
                    logger.warning(
                        "### Persistent WS ping failed, reconnecting..."
                    )
                    await self._disconnect()

            # Apply backoff delay based on how recently we disconnected
            backoff = self.BACKOFF_DELAYS[
                min(self._backoff_idx, len(self.BACKOFF_DELAYS) - 1)
            ]
            elapsed = time.time() - self._last_disconnect_time
            if elapsed < backoff and self._last_disconnect_time > 0:
                wait = backoff - elapsed
                logger.info(
                    f"### WS backoff: waiting {wait:.1f}s before reconnect"
                )
                await asyncio.sleep(wait)

            # Attempt reconnect with retries
            max_attempts = 5
            for attempt in range(max_attempts):
                try:
                    logger.info(
                        f"### WS connect attempt {attempt + 1}/{max_attempts}..."
                    )
                    await self._connect()
                    return
                except Exception as e:
                    self._backoff_idx = min(
                        self._backoff_idx + 1, len(self.BACKOFF_DELAYS) - 1
                    )
                    self._last_disconnect_time = time.time()
                    if attempt < max_attempts - 1:
                        delay = self.BACKOFF_DELAYS[
                            min(self._backoff_idx, len(self.BACKOFF_DELAYS) - 1)
                        ]
                        logger.warning(
                            f"### WS connect failed ({e}), "
                            f"retrying in {delay}s..."
                        )
                        await asyncio.sleep(delay)

            raise RuntimeError(
                f"Failed to connect to Gateway after {max_attempts} attempts"
            )

    # ------------------------------------------------------------------ #
    # Abort helper                                                         #
    # ------------------------------------------------------------------ #

    async def abort_run(self, ws, run_id, session_key, reason="voice-disconnect"):
        """Send chat.abort to prevent session poisoning on the Gateway side."""
        try:
            abort_req = {
                "type": "req",
                "id": f"abort-{run_id}",
                "method": "chat.abort",
                "params": {
                    "sessionKey": session_key,
                    "runId": run_id
                }
            }
            await ws.send(json.dumps(abort_req))
            logger.info(
                f"### ABORT sent for run {run_id[:12]}... reason={reason}"
            )
        except Exception as e:
            logger.warning(f"### Failed to send abort: {e}")

    # ------------------------------------------------------------------ #
    # Event streaming (runs on persistent WS in background loop)          #
    # ------------------------------------------------------------------ #

    async def _stream_events(self, ws, event_queue, message, session_key,
                             captured_actions, agent_id=None):
        """
        Send chat.send on the existing WS and stream response events into
        event_queue.  No new connection is opened — we reuse the persistent WS.

        Events placed on event_queue:
          {'type': 'delta', 'text': str}
          {'type': 'action', 'action': dict}
          {'type': 'text_done', 'response': str|None, 'actions': list}
          {'type': 'error', 'error': str}

        agent_id: optional OpenClaw agent ID to route to (e.g. 'pi-guy').
                  Omit to use the default agent ('main').
        """
        prev_text_len = 0
        chat_id = str(uuid.uuid4())

        # Load system prompt from file (hot-reload — changes take effect on next message)
        system_prompt = _load_system_prompt()

        full_message = f"{system_prompt}\n\nUser message: {message}"
        print(f"[DEBUG GW] Sending to gateway ({len(full_message)} chars). User part: {repr(message[:120])}", flush=True)

        chat_params = {
            "message": full_message,
            "sessionKey": session_key,
            "idempotencyKey": chat_id
        }
        # NOTE: agentId is NOT passed to chat.send — OpenClaw WEBCHAT gateway
        # routes by primary model config in openclaw.json, not per-request agentId.
        # Model switching is handled by profiles.py patching openclaw.json + restarting gateway.

        chat_request = {
            "type": "req",
            "id": f"chat-{chat_id}",
            "method": "chat.send",
            "params": chat_params
        }
        logger.info(f"### Sending chat message (agent={agent_id or 'main'}): {message[:100]}")
        await ws.send(json.dumps(chat_request))

        timeout = 300
        start_time = time.time()
        collected_text = ''
        lifecycle_ended = False
        chat_final_seen = False
        subagent_active = False
        main_lifecycle_ended = False
        current_run_id = None   # set from the chat.send ack
        req_acked = False       # True once we receive our req's res

        while time.time() - start_time < timeout:
            try:
                response = await asyncio.wait_for(ws.recv(), timeout=5.0)
                data = json.loads(response)

                # ── ACK for our chat.send — extract runId ────────────────
                if (data.get('type') == 'res'
                        and data.get('id') == f'chat-{chat_id}'):
                    req_acked = True
                    result = data.get('result') or data.get('payload') or {}
                    current_run_id = (result.get('runId')
                                      or data.get('runId'))
                    logger.info(
                        f"### chat.send ACK "
                        f"runId={current_run_id[:8] if current_run_id else 'none'}"
                    )
                    continue

                # ── Stale-event guard ────────────────────────────────────
                # Skip agent/chat events that arrived before our ack —
                # they belong to a previous conversation.
                evt = data.get('event', '')
                if not req_acked and evt in ('agent', 'chat'):
                    stale_run = data.get('payload', {}).get('runId', '?')
                    logger.info(
                        f"### SKIP pre-ack stale {evt} "
                        f"runId={stale_run[:8] if stale_run else '?'}"
                    )
                    continue

                # Once acked, skip events whose runId doesn't match ours.
                if current_run_id and evt in ('agent', 'chat'):
                    event_run_id = data.get('payload', {}).get('runId', '')
                    if event_run_id and event_run_id != current_run_id:
                        logger.info(
                            f"### SKIP stale runId={event_run_id[:8]} "
                            f"(current={current_run_id[:8]})"
                        )
                        continue

                # Log all non-noise events for debugging
                if evt not in ('health', 'tick', 'presence', 'ping'):
                    payload = data.get('payload', {})
                    if not (evt == 'chat' and payload.get('state') == 'delta'):
                        logger.info(
                            f"### GW EVENT: {json.dumps(data)[:800]}"
                        )

                if (data.get('type') == 'event'
                        and data.get('event') == 'agent'):
                    payload = data.get('payload', {})

                    # Stream text deltas
                    if payload.get('stream') == 'assistant':
                        data = payload.get('data', {})
                        full_text = data.get('text', '')
                        delta_text = data.get('delta', '')
                        # Use delta field directly — avoids prev_text_len desync
                        # when agent produces a second message after a tool call
                        # (the second segment's text starts fresh but prev_text_len
                        # would still hold the length of the first segment).
                        if delta_text and full_text:
                            prev_text_len = len(full_text)
                            collected_text = full_text
                            event_queue.put({'type': 'delta', 'text': delta_text})
                        elif full_text and len(full_text) > prev_text_len:
                            # fallback for events without a delta field
                            delta_text = full_text[prev_text_len:]
                            prev_text_len = len(full_text)
                            collected_text = full_text
                            event_queue.put({'type': 'delta', 'text': delta_text})

                    # Track tool use (requires caps: ["tool-events"])
                    if payload.get('stream') == 'tool':
                        tool_data = payload.get('data', {})
                        phase = tool_data.get('phase', '')
                        action = {
                            'type': 'tool',
                            'phase': phase,
                            'name': tool_data.get('name', 'unknown'),
                            'toolCallId': tool_data.get('toolCallId', ''),
                            'ts': time.time()
                        }
                        if phase == 'result':
                            action['result'] = str(
                                tool_data.get('result', '')
                            )[:200]
                        captured_actions.append(action)
                        event_queue.put({'type': 'action', 'action': action})
                        if phase == 'start':
                            tool_name = tool_data.get('name', '?')
                            print(f"[DEBUG GW] TOOL CALL: {tool_name}", flush=True)
                            logger.info(f"### TOOL START: {tool_name}")
                            if tool_name in ('sessions_spawn',
                                             'sessions-spawn',
                                             'spawn_subagent'):
                                subagent_active = True
                                logger.info(
                                    f"### SUBAGENT SPAWN DETECTED via "
                                    f"tool call: {tool_name} — "
                                    f"switching to long-wait mode"
                                )
                                event_queue.put({'type': 'action', 'action': {
                                    'type': 'subagent', 'phase': 'spawning',
                                    'tool': tool_name, 'ts': time.time()
                                }})
                        elif phase == 'result':
                            logger.info(
                                f"### TOOL RESULT: {tool_data.get('name', '?')}"
                            )

                    # Track lifecycle events
                    if payload.get('stream') == 'lifecycle':
                        phase = payload.get('data', {}).get('phase', '')
                        sk = payload.get('sessionKey', '')
                        is_subagent = 'subagent:' in sk
                        action = {
                            'type': 'lifecycle',
                            'phase': phase,
                            'sessionKey': sk,
                            'ts': time.time()
                        }
                        captured_actions.append(action)

                        if phase == 'start' and is_subagent:
                            subagent_active = True
                            logger.info(
                                f"### SUBAGENT DETECTED: {sk} — "
                                f"switching to long-wait mode"
                            )
                            event_queue.put({'type': 'action', 'action': {
                                'type': 'subagent', 'phase': 'start',
                                'sessionKey': sk, 'ts': time.time()
                            }})

                        if phase == 'end' and is_subagent:
                            logger.info(
                                f"### SUBAGENT ENDED: {sk} — "
                                f"waiting for announce-back"
                            )
                            event_queue.put({'type': 'action', 'action': {
                                'type': 'subagent', 'phase': 'end',
                                'sessionKey': sk, 'ts': time.time()
                            }})

                        if phase == 'end' and not is_subagent:
                            lifecycle_ended = True
                            if subagent_active:
                                main_lifecycle_ended = True
                                partial = (collected_text[:200]
                                           if collected_text else '(none)')
                                logger.info(
                                    f"### Main lifecycle.end with "
                                    f"subagent active — NOT returning. "
                                    f"Partial text: {partial}..."
                                )
                                # Reset text tracking for announce-back
                                prev_text_len = 0
                                collected_text = ''
                            elif collected_text:
                                logger.info(
                                    f"### ✓✓✓ AI RESPONSE (lifecycle end): "
                                    f"{collected_text[:200]}..."
                                )
                                event_queue.put({
                                    'type': 'text_done',
                                    'response': collected_text,
                                    'actions': captured_actions
                                })
                                return

                # Chat final event
                if (data.get('type') == 'event'
                        and data.get('event') == 'chat'):
                    payload = data.get('payload', {})
                    if payload.get('state') == 'final':
                        logger.info(
                            f"### CHAT FINAL payload: "
                            f"{json.dumps(payload)[:1500]}"
                        )
                        chat_final_seen = True

                        # Try extracting text from message content
                        final_text = collected_text
                        if not final_text and 'message' in payload:
                            content = payload['message'].get('content', '')
                            if isinstance(content, list):
                                text_parts = [
                                    item['text'] for item in content
                                    if item.get('type') == 'text'
                                    and item.get('text', '').strip()
                                ]
                                content = ' '.join(text_parts)
                            if content and content.strip():
                                final_text = content

                        if final_text:
                            print(f"[DEBUG GW] chat.final text ({len(final_text)} chars): {repr(final_text[:200])}", flush=True)
                            logger.info(
                                f"### ✓✓✓ AI RESPONSE (chat final): "
                                f"{final_text[:200]}..."
                            )
                            event_queue.put({
                                'type': 'text_done',
                                'response': final_text,
                                'actions': captured_actions
                            })
                            return

                        # Empty chat.final — check subagent state
                        if subagent_active or main_lifecycle_ended:
                            logger.info(
                                "### chat.final with no text — "
                                "subagent mode, waiting for announce-back..."
                            )
                            chat_final_seen = False
                            lifecycle_ended = False
                            prev_text_len = 0
                            continue
                        else:
                            logger.warning(
                                "### chat.final with no text (no subagent)"
                            )
                            await self.abort_run(
                                ws, chat_id, session_key, "empty-response"
                            )
                            event_queue.put({
                                'type': 'text_done',
                                'response': None,
                                'actions': captured_actions
                            })
                            return

            except asyncio.TimeoutError:
                if subagent_active and not collected_text:
                    elapsed = int(time.time() - start_time)
                    if elapsed % 30 < 6:
                        logger.info(
                            f"### Waiting for subagent announce-back... "
                            f"({elapsed}s elapsed)"
                        )
                    continue
                if collected_text and lifecycle_ended:
                    event_queue.put({
                        'type': 'text_done',
                        'response': collected_text,
                        'actions': captured_actions
                    })
                    return
                if lifecycle_ended and chat_final_seen:
                    event_queue.put({
                        'type': 'text_done',
                        'response': None,
                        'actions': captured_actions
                    })
                    return
                continue

        # Hard timeout fallback
        print(f"[DEBUG GW] hard timeout. collected_text ({len(collected_text)} chars): {repr(collected_text[:200])}", flush=True)
        if collected_text:
            event_queue.put({
                'type': 'text_done',
                'response': collected_text,
                'actions': captured_actions
            })
        else:
            await self.abort_run(ws, chat_id, session_key, "timeout")
            event_queue.put({
                'type': 'text_done',
                'response': None,
                'actions': captured_actions
            })

    # ------------------------------------------------------------------ #
    # Main async entry point (runs in background loop)                    #
    # ------------------------------------------------------------------ #

    async def _do_stream(self, event_queue, message, session_key,
                         captured_actions, agent_id=None):
        """Ensure persistent WS is connected, then stream events."""
        try:
            await self._ensure_connected()
        except RuntimeError as e:
            event_queue.put({'type': 'error', 'error': str(e)})
            return

        ws = self._ws
        try:
            # Emit handshake event with ms=0 to signal persistent connection
            # (handshake cost is amortised — only paid on first connect)
            event_queue.put({'type': 'handshake', 'ms': 0})
            async with self._stream_lock:
                await self._stream_events(
                    ws, event_queue, message, session_key, captured_actions,
                    agent_id=agent_id
                )
        except (websockets.exceptions.ConnectionClosed,
                websockets.exceptions.ConnectionClosedError,
                websockets.exceptions.ConnectionClosedOK) as e:
            logger.warning(
                f"### WS connection closed mid-stream: {e}, reconnecting..."
            )
            await self._disconnect()
            # Retry once with a fresh connection
            try:
                await self._ensure_connected()
                ws = self._ws
                async with self._stream_lock:
                    await self._stream_events(
                        ws, event_queue, message, session_key, captured_actions,
                        agent_id=agent_id
                    )
            except Exception as e2:
                logger.error(f"### Gateway retry failed: {e2}")
                event_queue.put({'type': 'error', 'error': str(e2)})
        except Exception as e:
            import traceback
            logger.error(f"Clawdbot Gateway error: {e}")
            traceback.print_exc()
            event_queue.put({'type': 'error', 'error': str(e)})

    # ------------------------------------------------------------------ #
    # Public synchronous interface                                         #
    # ------------------------------------------------------------------ #

    def stream_to_queue(self, event_queue, message, session_key,
                        captured_actions=None, agent_id=None):
        """
        Send a chat message to Gateway and stream events into event_queue.

        Synchronous (blocking).  Safe to call from any thread.
        Uses the persistent background WS connection — handshake cost is
        paid only on the first call (or after a reconnect).

        Events placed on event_queue:
          {'type': 'handshake', 'ms': int}   — connection ready (ms=0 if reused)
          {'type': 'delta', 'text': str}     — streaming text chunk
          {'type': 'action', 'action': dict} — tool/lifecycle event
          {'type': 'text_done', 'response': str|None, 'actions': list}
          {'type': 'error', 'error': str}

        Args:
            event_queue:      thread-safe queue.Queue() for yielded events
            message:          user message string to send
            session_key:      Gateway session key (e.g. 'voice-main-7')
            captured_actions: list to append tool/lifecycle actions to;
                              created internally if None
            agent_id:         optional OpenClaw agent ID (e.g. 'pi-guy').
                              Omit to route to the default 'main' agent.
        """
        if captured_actions is None:
            captured_actions = []

        self._ensure_started()

        future = asyncio.run_coroutine_threadsafe(
            self._do_stream(event_queue, message, session_key, captured_actions,
                            agent_id=agent_id),
            self._loop
        )
        try:
            future.result(timeout=320)  # slightly longer than Gateway 300s timeout
        except Exception as e:
            logger.error(f"Gateway stream error: {e}")
            event_queue.put({'type': 'error', 'error': str(e)})


# ---------------------------------------------------------------------------
# GatewayRouter — one persistent connection per gateway URL, routes by
# agent_id. No restarts, no config patching, always warm.
#
# Gateway map (add entries as new agents are deployed):
#   'default' → CLAWDBOT_GATEWAY_URL env var (fallback: ws://127.0.0.1:18791)
#   Add additional named agents here as needed.
# ---------------------------------------------------------------------------

_GATEWAY_URLS: dict[str, str] = {
    'default': os.getenv('CLAWDBOT_GATEWAY_URL', 'ws://127.0.0.1:18791'),
}

# Session key map: which persistent session key to use per agent
_GATEWAY_SESSION_KEYS: dict[str, str] = {
    'default': None,   # uses get_voice_session_key() from conversation.py
}


class GatewayRouter:
    """Routes requests to the correct GatewayConnection based on agent_id.

    Each unique gateway URL gets its own persistent WS connection, so all
    agents stay warm simultaneously. No restarts needed when switching.
    """

    def __init__(self):
        self._connections: dict[str, GatewayConnection] = {}

    def _get_connection(self, agent_id: str | None) -> GatewayConnection:
        url_key = agent_id if agent_id in _GATEWAY_URLS else 'default'
        url = _GATEWAY_URLS[url_key]
        if url not in self._connections:
            conn = GatewayConnection()
            conn._custom_url = url   # override the env-based URL
            self._connections[url] = conn
            logger.info(f'GatewayRouter: new connection for {url_key} → {url}')
        return self._connections[url]

    def is_configured(self) -> bool:
        # Use the default connection to check auth token
        return bool(os.getenv('CLAWDBOT_AUTH_TOKEN'))

    def stream_to_queue(self, event_queue, message, session_key,
                        captured_actions=None, agent_id=None):
        conn = self._get_connection(agent_id)
        conn.stream_to_queue(event_queue, message, session_key,
                             captured_actions, agent_id=agent_id)


gateway_connection = GatewayRouter()
